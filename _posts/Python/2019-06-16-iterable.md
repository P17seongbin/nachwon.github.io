---
layout: post
title: '[Python] Iterable, Iterator, Generator'
excerpt: 파이썬의 Iterable, Iterator, Generator 객체에 대해 알아본다.
project: false
tags:
  - Python
  - Iterable
  - Iterator
  - Generator
category: Python
---

*Fluent Python 14장 내용을 요약한 것입니다.*

# Sentence 클래스 구현하기

Iterable, Iterator, Generator를 쉽게 이해하기 위해서 `Sentence` 라는 예제 객체를 만들어볼 것이다.

Sentence 클래스는 문자열을 받아서 단어별로 나누어서 반복하는 클래스이다.

```python
import re
import reprlib

RE_WORD = re.compile('\w+')

class Sentence:
    # instantiate 할 때 text를 받아서 문자열만 분리하여 리스트로 self.words에 저장
    def __init__(self, text):
        self.text = text
        self.words = RE_WORD.findall(text)

    # index를 받으면 index에 해당하는 단어를 리턴
    def __getitem__(self, index):
        return self.words[index]
    
    # 시퀀스 프로토콜에 완전히 따르려면 __len__을 구현해야하지만, iterable 객체에 필수적인 것은 아니다.
    def __len__(self):
        return len(self.words)

    def __repr__(self):
        return 'Sentence(%s)' % reprlib.repr(self.text)
```

```python
# Sentence 객체에 문자열을 전달하여 인스턴스를 하나 만든다.
s = Sentence('"The time has come," the Walrus said,')

# for문을 이용해서 각 요소를 돌면서 하나씩 print 한다.
for word in s:
    print(word)
```
```
The
time
has
come
the
Walrus
said
```

---
# Iter()

Sentence 객체의 인스턴스인 `s` 는 어떻게 for문으로 반복이 가능할까?
Python 인터프리터가 어떤 객체 `x`를 반복해야할 때는 항상 내장함수 `iter(x)`를 호출한다.

iter() 함수는 다음의 과정을 수행한다.

1. 객체가 `__iter__()` 메서드를 가지고 있으면, 이 메서드를 호출해서 `Iterator` 객체를 가져온다.
2. `__iter__()` 가 없지만 `__getitem__()` 이 구현되어 있는 경우, 파이썬은 0번째에서 시작해서 항목을 차례로 가져오는 Iterator를 생성한다.
3. `__getitem__()` 도 없는 경우 `TypeError: '클래스명' object is not iterable` 이라는 메세지와 함께 `TypeError` 가 발생한다.

모든 Sequence 객체는 `__getitem__()` 을 가지고 있으므로 Iterable 객체라고 할 수 있다. iter() 함수가 `__getitem__()` 까지 고려해주기 때문인데, 이는 하위호환성 때문이다.

### * 객체가 Iterable 인지 체크하기

어떤 객체가 Iterable 객체인지 확인하는 가장 정확한 방법은 iter(x) 를 호출해서 TypeError 가 발생하는지 확인하는 것이다.

iter(x) 는 `__getitem__()` 까지 확인을 하는 반면, `issubclass(x, abc.Iterable)` 는 그렇지 않기 때문이다.

```python
from collections import abc

s = Sentence('test test')

# Iterator 객체를 리턴함.
iter(s)  # <iterator object at 0x0000016537225278>

# Sentence는 Iterable 객체이지만 issubclass 검사를 통과하지 못한다.
# __iter__() 가 없기 때문.
issubclass(Sentence, abc.Iterable)  # False
```

---

# Iterable 과 Iterator 의 정의

위에서 살펴본 내용을 바탕으로 Iterable 을 정의하면,

> ### Iterable의 정의
> - iter() 내장 함수가 Iterator 객체를 가져올 수 있는 모든 객체.  
> - Iterator 객체를 리턴하는 `__iter__()` 를 가지고 있는 객체.  
> - 0부터 시작하는 인덱스를 받는 `__getitem__()` 를 가지고 있는 객체.

즉, 결국 인터프리터가 반복을 수행하기 위해서 필요한 것은 `Iterator` 객체이며, `Iterable` 객체는 인터프리터에게 `Iterator` 를 반환해주는 객체임을 알 수 있다.

그렇다면 `Iterator` 는 무엇일까?

다음은 문자열을 반복하는 간단한 for 루프이다.

```python
s = 'ABC'
for char in s:
    print(char)
```
```
A
B
C
```

이것을 while 문으로 똑같이 흉내내면 다음과 같다.

```python
s = 'ABC'  # string 도 Iterable 객체이다.
it = iter(s)  # Iterator 객체를 생성한다.

while True:
    try:
        print(next(it))  # next 를 호출해서 다음 항목을 가져온다.
    except StopIteration:  # 더 이상 항목이 없으면 StopIteration 에러가 발생한다.
        del it  # it 참조 해제
        break  # 루프 정지
```

iter() 함수에 의해 반환된 Iterator 객체에는 `next()` 내장 함수를 사용하여 다음 항목을 반환하게 할 수 있으며, 다음 항목이 없을 경우 StopIteration 에러를 발생시킨다.

위 예에서 알아본 것 처럼 Iterator 객체의 표준 인터페이스는 다음의 메서드들을 정의한다.

1. next() 내장 함수에 의해 호출되어 다음 항목을 리턴하는 `__next__()`. 모든 항목을 다 반복한 경우 StopIteration 에러를 발생시킨다.
2. 자기 자신을 리턴하는 `__iter__()`.

이를 바탕으로 Iterator를 정의해보면,

> ### Iterator의 정의
> - 다음 항목을 반환하거나, 다음 항목이 없을 때 StopIteration 을 발생시키는 `__next__()` 와 자기 자신을 리턴하는 `__iter__()` 를 가지고 있는 객체.
> - `__iter__()` 를 가지고 있으므로 Iterator 는 Iterable 이기도 하다.

### * 객체가 Iterator 인지 체크하기

Python 3.4의 `Lib/types.py` 모듈 소스 코드에 다음과 같은 주석이 있다.

```python
# Iterators in Python aren't a matter of type but of protocol. A large
# and changing number of builtin types implement *some* flavor of
# iterator. Don't check the type! Use hasattr to check for both
# "__iter__" and "__next__" attributes instead.
```

이에 따라 어떤 객체가 Iterator 객체인지 확인하는 가장 좋은 방법은 `isinstance(x, abc.Iterator)` 를 호출하는 것이다.

다음은 abc.Iterator 의 소스 코드이다.

```python
class Iterator(Iterable):

    __slot__ = ()

    @abstractmethod
    def __next__(self):
        raise StopIteration

    def __iter__(self):
        return self

    @classmethod
    def __subclasshook__(cls, C):
        if cls is Iterator:
            if (any("__next__" in B.__dict__ for B in C.__mro__) and
                any("__iter__" in B.__dict__ for B in C.__mro__)):
                return True
        return NotImplemented
```

`__subclasshook__()` 는 `isinstance()` 또는 `issubclass()` 내장 함수가 호출될 때 실행되는 함수이다.

abc.Iterator 에 구현된 `__subclasshook__()` 는 검사 대상 클래스가 상속하는 모든 클래스들을 돌면서 `__next__` 와 `__iter__` 가 있는지 확인한다.

덕분에 직접 Iterator 객체를 상속받은 서브클래스들 뿐만 아니라, `__next__()` 와 `__iter__()` 를 구현하고 있는 가상 서브클래스들까지도 통과시켜준다.

```python
from collections.abc import Iterator

class fakeIterator:
    def __next__(self):
        pass

    def __iter__(self):
        pass

f = fakeIterator()
isinstance(f, Iterator)  # True
```

---

# Sentence 클래스 V2: Iterator 버전

